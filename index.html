<script>
        const pdfjsLib = window['pdfjs-dist/build/pdf'];
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
        
        const MONTHS = ["JANEIRO", "FEVEREIRO", "MARÇO", "ABRIL", "MAIO", "JUNHO", "JULHO", "AGOSTO", "SETEMBRO", "OUTUBRO", "NOVEMBRO", "DEZEMBRO"];

        // --- SISTEMA DE TABS ---
        function showTab(id, el) {
            document.querySelectorAll('.tab-content').forEach(c => { c.classList.remove('active'); c.style.display = 'none'; });
            document.querySelectorAll('.nav-link').forEach(n => n.classList.remove('active'));
            const target = document.getElementById(id);
            if(target) { target.classList.add('active'); target.style.display = 'block'; }
            if(el) el.classList.add('active');
            if(id === 'xml-history-panel') renderXMLHistory();
            if(id === 'pgdas-history-panel') renderPGDASHistory();
        }

        // --- MOTOR XML (CORRIGIDO E TURBINADO) ---
        let xmlBuffer = [];

        async function handleXMLFiles(files) {
            xmlBuffer = [];
            const label = document.getElementById('label-xml');
            label.innerText = "Lendo arquivos...";
            
            for (let f of files) {
                if (f.name.toLowerCase().endsWith('.zip')) {
                    try {
                        const zip = await JSZip.loadAsync(f);
                        const xmlFiles = Object.keys(zip.files).filter(x => x.toLowerCase().endsWith('.xml'));
                        for (let p of xmlFiles) {
                            xmlBuffer.push(await zip.files[p].async("text"));
                        }
                    } catch(e) { console.error("Erro no ZIP", e); }
                } else if (f.name.toLowerCase().endsWith('.xml')) {
                    xmlBuffer.push(await f.text());
                }
            }
            label.innerText = `${xmlBuffer.length} XMLs Carregados (Clique em Gravar)`;
            document.getElementById('btn-run-xml').disabled = false;
        }

        // Função auxiliar para pegar valor de tag com segurança
        const getTag = (el, tag) => el.getElementsByTagName(tag)[0]?.textContent || "";
        
        // Função para pegar CST/CSOSN específico dentro de um grupo (PIS, COFINS, etc)
        const getTaxCST = (det, groupTag, fieldTags) => {
            const group = det.getElementsByTagName(groupTag)[0];
            if (!group) return "";
            for (let tag of fieldTags) {
                const val = group.getElementsByTagName(tag)[0]?.textContent;
                if (val) return val;
            }
            return "";
        };

        function processarXML() {
            if (xmlBuffer.length === 0) return alert("Nenhum arquivo carregado.");
            
            const db = JSON.parse(localStorage.getItem('xml_audit_history')) || [];
            // Mapa temporário para agrupar antes de salvar
            const groups = {}; 

            xmlBuffer.forEach(text => {
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, "text/xml");
                
                // 1. Identificação da Nota
                const ide = xml.getElementsByTagName("ide")[0];
                const emit = xml.getElementsByTagName("emit")[0];
                
                if (!ide || !emit) return; // XML inválido

                const cnpj = getTag(emit, "CNPJ");
                const xNome = getTag(emit, "xNome");
                const nNF = getTag(ide, "nNF");
                
                // 2. Tratamento da Data (dhEmi ou dEmi)
                let rawDate = getTag(ide, "dhEmi") || getTag(ide, "dEmi");
                if (!rawDate) return;
                
                // Converte string ISO para objeto Date (ex: 2026-02-09T...)
                const dateObj = new Date(rawDate);
                if (isNaN(dateObj.getTime())) return; // Data inválida

                const mesIndex = dateObj.getMonth(); // 0 a 11
                const ano = dateObj.getFullYear();
                
                // Formato exigido: FEVEREIRO/2026
                const refPorExtenso = `${MONTHS[mesIndex]}/${ano}`;
                
                // Chave única para agrupamento: CNPJ + ANO + MÊS
                const key = `${cnpj}_${ano}_${mesIndex}`;

                // Cria o grupo se não existir
                if (!groups[key]) {
                    groups[key] = {
                        key: key,
                        empresa: xNome,
                        cnpj: cnpj,
                        ref: refPorExtenso, // Exibição
                        mesSort: parseInt(`${ano}${mesIndex.toString().padStart(2,'0')}`), // Ordenação
                        qtd: 0,
                        itens: []
                    };
                }

                // Incrementa contador de notas
                groups[key].qtd++;

                // 3. Extração dos Itens (Produtos)
                const dets = xml.getElementsByTagName("det");
                Array.from(dets).forEach(det => {
                    const prod = det.getElementsByTagName("prod")[0];
                    if (!prod) return;

                    groups[key].itens.push({
                        nomeEmitente: xNome,
                        cnpjEmitente: cnpj,
                        mesAno: refPorExtenso,
                        nNF: nNF,
                        ncm: getTag(prod, "NCM"),
                        xProd: getTag(prod, "xProd"),
                        vUnCom: getTag(prod, "vUnCom"), // Valor Unitário
                        vProd: getTag(prod, "vProd"),   // Valor Total
                        
                        // Extração Específica de Impostos
                        cstPis: getTaxCST(det, "PIS", ["CST"]),
                        cstCofins: getTaxCST(det, "COFINS", ["CST"]),
                        cstIpi: getTaxCST(det, "IPI", ["CST"]),
                        // ICMS pode ser CST ou CSOSN
                        icmsCstCsosn: getTaxCST(det, "ICMS", ["CST", "CSOSN", "orig"]) // Tenta achar qualquer um
                    });
                });
            });

            // Mesclar com o banco de dados existente
            // Se já existe o grupo, substituímos ou somamos? Aqui vou adicionar novos grupos ou atualizar existentes.
            Object.values(groups).forEach(newGroup => {
                const existingIndex = db.findIndex(h => h.key === newGroup.key);
                if (existingIndex >= 0) {
                    // Se já existe, atualiza (substitui para evitar duplicidade de itens da mesma carga)
                    db[existingIndex] = newGroup;
                } else {
                    db.push(newGroup);
                }
            });

            localStorage.setItem('xml_audit_history', JSON.stringify(db));
            alert(`✅ Processamento Concluído!\n${Object.keys(groups).length} Referências processadas.`);
            renderXMLHistory();
            
            // Limpa buffer para liberar memória
            xmlBuffer = [];
            document.getElementById('label-xml').innerText = "Carregar arquivos";
            document.getElementById('btn-run-xml').disabled = true;
        }

        // --- MOTOR PGDAS (Mantido igual, se quiser alterar avise) ---
        let pgdasFiles = [];
        function handlePGDASFiles(f) { pgdasFiles = Array.from(f); document.getElementById('label-pgdas').innerText = `${f.length} PDFs Prontos`; document.getElementById('btn-run-pgdas').disabled = false; }
        
        async function processarPGDAS() {
            const h = JSON.parse(localStorage.getItem('pgdas_pdf_audit')) || [];
            for(let file of pgdasFiles) {
                const pdf = await pdfjsLib.getDocument(await file.arrayBuffer()).promise;
                let text = ""; for(let i=1; i<=pdf.numPages; i++) text += (await (await pdf.getPage(i)).getTextContent()).items.map(it => it.str).join(" ") + " ";
                const clean = text.replace(/\s+/g, ' ');
                const cnpj = (clean.match(/(\d{2}\.\d{3}\.\d{3}\/\d{4}-\d{2})/) || [""])[0];
                const p = clean.match(/Período de Apuração:\s*01\/(\d{2})\/(\d{4})/);
                if(!p) continue;
                const ref = `${MONTHS[parseInt(p[1])-1]}/${p[2]}`;
                if(h.some(x => x.cnpj === cnpj && x.ref === ref)) continue;
                let atividades = [];
                clean.split("Valor do Débito por Tributo para a Atividade").slice(1).forEach(b => {
                    const impostos = b.match(/[\d.]+,\d{2}/g);
                    const descMatch = b.match(/^(.*?)\s*Receita Bruta Informada/);
                    if(impostos && impostos.length > 8) {
                        atividades.push({ desc: descMatch ? descMatch[1].trim() : "Atividade", receita: (b.match(/Receita Bruta Informada\s*:\s*R\$\s*([\d.]+,\d{2})/) || ["","0,00"])[1], total: impostos[8], det: impostos });
                    }
                });
                h.push({ razao: (clean.match(/Nome empresarial:\s*(.*?)\s*Data/) || ["","EMPRESA"])[1], cnpj, ref, mSort: parseInt(p[2]+p[1]), rbt12: (clean.match(/RBT12\)\s*[\d.,]+\s*[\d.,]+\s*([\d.]+,\d{2})/) || ["","0,00"])[1], atividades, dasTotal: (clean.match(/Valor Total do DAS:\s*([\d.]+,\d{2})/) || ["","0,00"])[1] });
            }
            localStorage.setItem('pgdas_pdf_audit', JSON.stringify(h));
            alert("✅ PGDAS Gravados!"); renderPGDASHistory();
        }

        // --- RENDERIZADORES ---
        function renderXMLHistory() {
            const h = JSON.parse(localStorage.getItem('xml_audit_history')) || [];
            // Ordenar por data (mais recente primeiro)
            h.sort((a, b) => b.mesSort - a.mesSort);

            document.getElementById('tbody-xml').innerHTML = h.map((it, i) => `<tr>
                <td><input type="checkbox" class="xml-sel" data-idx="${i}"></td>
                <td><b class="text-white uppercase text-[10px]">${it.empresa}</b><br><small class="text-zinc-500">${it.cnpj}</small></td>
                <td class="text-orange-500 font-bold uppercase">${it.ref}</td>
                <td class="text-white font-black text-center">${it.qtd}</td>
                <td><div class="flex items-center gap-3">
                    <button onclick="downloadOneXML(${i})" class="bg-zinc-800 text-white px-3 py-1 rounded text-[9px] uppercase hover:bg-zinc-700"><i class="fas fa-download mr-1"></i> CSV</button>
                    <i class="fas fa-trash-alt trash-icon" onclick="deleteItem('xml', ${i})"></i>
                </div></td></tr>`).join('') || '<tr><td colspan="5" class="text-center py-20 opacity-30 italic">Nenhum histórico encontrado</td></tr>';
        }

        function renderPGDASHistory() {
            const h = JSON.parse(localStorage.getItem('pgdas_pdf_audit')) || [];
            document.getElementById('tbody-pgdas').innerHTML = h.map((it, i) => `<tr>
                <td><b class="text-white uppercase text-[10px]">${it.razao}</b><br><small class="text-zinc-500">${it.cnpj} | ${it.ref}</small></td>
                <td class="font-bold text-zinc-400">R$ ${it.rbt12}</td>
                <td>${it.atividades.map(a => `<div class="activity-item">
                    <div class="text-[8px] font-bold text-white uppercase">${a.desc} - R$ ${a.receita}</div>
                    <div class="tax-grid">
                        <div class="tax-unit"><span>PIS</span><span>${a.det[3]}</span></div>
                        <div class="tax-unit"><span>COFINS</span><span>${a.det[2]}</span></div>
                        <div class="tax-unit"><span>ICMS</span><span>${a.det[5]}</span></div>
                        <div class="tax-unit"><span>TOTAL</span><span class="text-white font-bold">${a.total}</span></div>
                    </div></div>`).join('')}</td>
                <td class="text-orange-500 font-black text-[12px]">R$ ${it.dasTotal}</td>
                <td class="text-center"><i class="fas fa-trash-alt trash-icon" onclick="deleteItem('pgdas', ${i})"></i></td></tr>`).join('') || '<tr><td colspan="5" class="text-center py-20 opacity-30 italic">Vazio</td></tr>';
        }

        function deleteItem(type, idx) {
            const k = type === 'xml' ? 'xml_audit_history' : 'pgdas_pdf_audit';
            let d = JSON.parse(localStorage.getItem(k));
            // Como ordenamos na visualização, precisamos achar o item correto no array original
            // Simplificação: vamos re-buscar e deletar pelo Key ou Index direto se não tiver ordenação complexa
            // Para garantir, vamos usar filter no XML
            if (type === 'xml') {
                // Como renderizamos ordenado, o idx clicado não é o idx do localStorage.
                // Vamos refazer a lógica simples: deletar e renderizar. 
                // Nota: Ideal seria usar ID único, mas vamos deletar do array ordenado e salvar.
                d.sort((a, b) => b.mesSort - a.mesSort); // Aplica mesma ordenação
                if(confirm(`Excluir ${d[idx].ref}?`)) {
                    d.splice(idx, 1);
                    localStorage.setItem(k, JSON.stringify(d));
                    renderXMLHistory();
                }
            } else {
                if(confirm("Confirmar exclusão?")) { d.splice(idx, 1); localStorage.setItem(k, JSON.stringify(d)); renderPGDASHistory(); }
            }
        }

        function clearHistory(type) { if(confirm("Apagar TODO o histórico? Esta ação é irreversível.")) { localStorage.removeItem(type === 'xml' ? 'xml_audit_history' : 'pgdas_pdf_audit'); type === 'xml' ? renderXMLHistory() : renderPGDASHistory(); } }
        
        // --- GERADOR DE CSV DETALHADO ---
        function generateCSV(data) {
            // Cabeçalho ajustado conforme solicitação
            let csv = "\ufeffEmpresa;CNPJ Emitente;Mês/Ano;Nota;NCM;Descrição Produto;Vl. Unit;Vl. Total;CST PIS;CST COFINS;CST/CSOSN ICMS;CST IPI\n";
            
            data.forEach(d => {
                // Tratamento para evitar que ponto e vírgula no nome do produto quebre o CSV
                const descSegura = d.xProd.replace(/;/g, " ");
                const valorUnit = d.vUnCom.replace(".", ",");
                const valorTotal = d.vProd.replace(".", ",");

                csv += `${d.nomeEmitente};${d.cnpjEmitente};${d.mesAno};${d.nNF};${d.ncm};${descSegura};${valorUnit};${valorTotal};${d.cstPis};${d.cstCofins};${d.icmsCstCsosn};${d.cstIpi}\n`;
            });
            return csv;
        }

        function downloadOneXML(idx) {
            let d = JSON.parse(localStorage.getItem('xml_audit_history')) || [];
            d.sort((a, b) => b.mesSort - a.mesSort);
            const registro = d[idx];
            
            const csvContent = generateCSV(registro.itens);
            
            const link = document.createElement("a");
            link.href = URL.createObjectURL(new Blob([csvContent], { type: 'text/csv;charset=utf-8;' }));
            link.download = `AUDIT_${registro.empresa.replace(/\s+/g,'_')}_${registro.ref.replace('/','-')}.csv`;
            link.click();
        }
        
        function exportBatchXML() {
            // Pega todos os selecionados
            const checkboxes = document.querySelectorAll('.xml-sel:checked');
            if(checkboxes.length === 0) return alert("Selecione pelo menos um item da lista.");

            let d = JSON.parse(localStorage.getItem('xml_audit_history')) || [];
            d.sort((a, b) => b.mesSort - a.mesSort);

            // Junta os itens de todos os selecionados em um único CSVzão ou baixa vários?
            // Vamos baixar um CSV consolidado com tudo que foi selecionado
            let allItems = [];
            checkboxes.forEach(cb => {
                const idx = parseInt(cb.dataset.idx);
                if(d[idx]) allItems = allItems.concat(d[idx].itens);
            });

            const csvContent = generateCSV(allItems);
            const link = document.createElement("a");
            link.href = URL.createObjectURL(new Blob([csvContent], { type: 'text/csv;charset=utf-8;' }));
            link.download = `AUDITORIA_CONSOLIDADA_${new Date().getTime()}.csv`;
            link.click();
        }

        function toggleChecks(m) { document.querySelectorAll('.xml-sel').forEach(cb => cb.checked = m.checked); }
        
        document.addEventListener('DOMContentLoaded', () => { 
            renderXMLHistory(); 
            renderPGDASHistory(); 
            
            // Service Worker
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('./sw.js')
                    .then(reg => console.log('SW ok'))
                    .catch(err => console.log('SW erro', err));
            }
        });
    </script>
